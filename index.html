<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Professional Monitor</title>

  <link rel="apple-touch-icon" href="icon.png">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="manifest" href="manifest.json">

  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; text-align: center; padding: 20px; background-color: #f4f7f9; color: #333; }
    .container { max-width: 600px; margin: 0 auto; background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); }
    h2 { color: #007aff; margin-bottom: 25px; }
    input, button { padding: 12px 15px; margin: 8px 0; font-size: 16px; border-radius: 8px; border: 1px solid #ccc; transition: all 0.2s; }
    button { cursor: pointer; background-color: #007aff; color: white; border: none; margin-left: 10px; }
    button:hover { background-color: #0056b3; }
    #login input[type="password"] { width: 200px; }
    #secureArea button { margin: 5px; }
    #keyLog { list-style-type: none; padding: 0; margin-top: 10px; background: #fafafa; border: 1px solid #eee; border-radius: 6px; }
    #keyLog li { padding: 8px 15px; border-bottom: 1px solid #eee; font-size: 14px; }
    #keyLog li:last-child { border-bottom: none; }
    #replayOutput { margin-top: 15px; background: #e9ecef; padding: 15px; font-family: monospace; min-height: 50px; border-radius: 6px; white-space: pre-wrap; word-break: break-all; text-align: left; }
    .status-message { margin-top: 10px; font-weight: bold; }
    .status-success { color: green; }
    .status-error { color: red; }
  </style>
</head>
<body>

  <div class="container">
    <h2>üîê Monitor Dashboard</h2>
    <p>Keys Pressed: <strong id="keyCount">0</strong></p>

    <div id="login">
      <input type="password" id="pinInput" placeholder="Enter PIN (1234)" />
      <button onclick="MonitorApp.unlock()">Unlock</button>
      <p id="loginStatus" class="status-message"></p>
    </div>

    <div id="secureArea" style="display: none;">
      <button onclick="MonitorApp.resetCount()">üóëÔ∏è Reset Data</button>
      <button onclick="MonitorApp.lock()">üîí Lock</button>

      <div style="margin-top: 25px;">
        <h3>Key Log History</h3>
        <ul id="keyLog" style="text-align: left; max-height: 200px; overflow-y: auto;"></ul>
        <button onclick="MonitorApp.exportCSV()">üìÑ Export Log (CSV)</button>
        <p id="exportStatus" class="status-message"></p>
      </div>

      <div style="margin-top: 25px;">
        <h3>Typing Replay</h3>
        <button onclick="MonitorApp.replayTyping()">‚ñ∂Ô∏è Replay Typing</button>
        <div id="replayOutput"></div>
      </div>
    </div>
  </div>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const MonitorApp = {
        // --- CONFIGURATION ---
        PIN: "1234",
        STORAGE_KEY_COUNT: "monitorKeyCount",
        STORAGE_KEY_LOG: "monitorKeyLog",

        // --- STATE ---
        keyCount: 0,
        keyLog: [],
        isReplaying: false,
        replayTimeout: null,

        // --- CACHED DOM ELEMENTS ---
        elements: {
          keyCount: document.getElementById("keyCount"),
          pinInput: document.getElementById("pinInput"),
          loginStatus: document.getElementById("loginStatus"),
          loginDiv: document.getElementById("login"),
          secureAreaDiv: document.getElementById("secureArea"),
          keyLogList: document.getElementById("keyLog"),
          replayOutput: document.getElementById("replayOutput"),
          exportStatus: document.getElementById("exportStatus"),
        },

        init() {
          this.loadState();
          this.bindEvents();
          this.updateKeyCountDisplay();
        },

        // --- STATE MANAGEMENT ---
        loadState() {
          this.keyCount = parseInt(localStorage.getItem(this.STORAGE_KEY_COUNT) || "0");
          try {
            this.keyLog = JSON.parse(localStorage.getItem(this.STORAGE_KEY_LOG) || "[]");
          } catch (e) {
            this.keyLog = [];
          }
        },

        saveState() {
          localStorage.setItem(this.STORAGE_KEY_COUNT, this.keyCount);
          localStorage.setItem(this.STORAGE_KEY_LOG, JSON.stringify(this.keyLog));
        },

        updateKeyCountDisplay() {
          this.elements.keyCount.textContent = this.keyCount;
        },

        // --- EVENT BINDING ---
        bindEvents() {
          document.addEventListener("keydown", (e) => this.handleKeyDown(e));
          // Expose functions globally for HTML buttons
          window.MonitorApp = this; 
        },

        handleKeyDown(e) {
          // Ignore common modifier and function keys for cleaner logs
          if (e.metaKey || e.ctrlKey || e.altKey || e.key.length > 1 && !['Enter', 'Tab', 'Space', 'Backspace', 'Delete', 'Escape', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
            return;
          }

          this.keyCount++;
          
          let keyToLog = e.key;
          // Normalize special keys for readability
          if (keyToLog === " ") keyToLog = "[Space]";
          if (keyToLog === "Enter") keyToLog = "[Return]";
          if (keyToLog === "Backspace") keyToLog = "[Back]";
          if (keyToLog === "Tab") keyToLog = "[Tab]";

          const logEntry = {
            key: keyToLog,
            time: new Date().toISOString()
          };
          this.keyLog.push(logEntry);
          
          this.saveState();
          this.updateKeyCountDisplay();

          // Only display in the list if the secure area is visible
          if (this.elements.secureAreaDiv.style.display === "block") {
            this.addKeyToLogList(logEntry);
          }
        },
        
        // --- AUTHENTICATION ---
        unlock() {
          const inputPin = this.elements.pinInput.value;
          
          if (inputPin === this.PIN) {
            this.elements.loginDiv.style.display = "none";
            this.elements.secureAreaDiv.style.display = "block";
            this.elements.loginStatus.textContent = "";
            this.loadKeyLogList();
            this.elements.replayOutput.textContent = ""; // Clear replay on login
          } else {
            this.elements.loginStatus.textContent = "‚ùå Incorrect PIN. Try 1234.";
            this.elements.loginStatus.classList.remove('status-success');
            this.elements.loginStatus.classList.add('status-error');
          }
          this.elements.pinInput.value = ""; // Always clear input
        },

        lock() {
          this.elements.secureAreaDiv.style.display = "none";
          this.elements.loginDiv.style.display = "block";
          this.elements.loginStatus.textContent = "";
          this.elements.pinInput.value = "";
          this.stopReplay();
        },

        // --- SECURE AREA ACTIONS ---
        resetCount() {
          this.keyCount = 0;
          this.keyLog = [];
          this.saveState();
          
          this.elements.keyCount.textContent = "0";
          this.elements.keyLogList.innerHTML = "";
          this.elements.replayOutput.textContent = "Data has been completely reset.";
          this.stopReplay();
        },
        
        loadKeyLogList() {
          this.elements.keyLogList.innerHTML = "";
          this.keyLog.slice(-50).forEach(entry => { // Show max 50 recent entries
            this.addKeyToLogList(entry);
          });
          this.elements.keyLogList.scrollTop = this.elements.keyLogList.scrollHeight;
        },

        addKeyToLogList(entry) {
            const li = document.createElement("li");
            // Format time for cleaner display in the list
            const date = new Date(entry.time);
            const timeStr = date.toLocaleTimeString() + "." + String(date.getMilliseconds()).padStart(3, '0');
            li.textContent = `${timeStr} ‚Äî ${entry.key}`;
            this.elements.keyLogList.appendChild(li);
            // Auto-scroll to show latest entry
            this.elements.keyLogList.scrollTop = this.elements.keyLogList.scrollHeight;
        },

        exportCSV() {
          if (this.keyLog.length === 0) {
            this.elements.exportStatus.textContent = "No data to export.";
            this.elements.exportStatus.classList.add('status-error');
            return;
          }
          
          const csvRows = [["Time", "Key"]];
          this.keyLog.forEach(({ time, key }) => {
            // Ensure no commas break the CSV structure if a key contained one (unlikely with filtered keys)
            csvRows.push([`"${time}"`, `"${key}"`]); 
          });
          
          const csv = csvRows.map(row => row.join(",")).join("\n");
          const blob = new Blob([csv], { type: "text/csv" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `monitor_log_${new Date().toISOString().slice(0, 10)}.csv`;
          a.click();
          URL.revokeObjectURL(url);
          
          this.elements.exportStatus.textContent = `‚úÖ Exported ${this.keyLog.length} keys.`;
          this.elements.exportStatus.classList.remove('status-error');
          this.elements.exportStatus.classList.add('status-success');
          setTimeout(() => this.elements.exportStatus.textContent = '', 3000);
        },

        // --- REPLAY FEATURE ---
        stopReplay() {
            clearTimeout(this.replayTimeout);
            this.isReplaying = false;
        },

        replayTyping() {
          this.stopReplay(); 
          const output = this.elements.replayOutput;
          output.textContent = "";

          if (this.keyLog.length === 0) {
            output.textContent = "No keys to replay.";
            return;
          }
          
          this.isReplaying = true;
          let i = 0;
          const step = () => {
            if (i >= this.keyLog.length || !this.isReplaying) {
              this.isReplaying = false;
              output.textContent += "\n‚Äî END OF REPLAY ‚Äî";
              return;
            }

            const key = this.keyLog[i].key;
            output.textContent += key;

            const currentTime = new Date(this.keyLog[i].time).getTime();
            const nextTime = this.keyLog[i + 1] ? new Date(this.keyLog[i + 1].time).getTime() : currentTime;
            
            // Calculate delay, but cap it for practical replay (max 200ms)
            const delay = Math.min(nextTime - currentTime, 200);

            i++;
            this.replayTimeout = setTimeout(step, Math.max(delay, 50)); // Min delay of 50ms
          };

          step();
        }
      };

      MonitorApp.init();
    });
  </script>
</body>
</html>
